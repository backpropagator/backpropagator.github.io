// Research DNA Visualization using D3.js
document.addEventListener('DOMContentLoaded', function() {
  const container = document.getElementById('research-dna-viz');
  if (!container) return;

  // Load publication data from DOM (generated by Jekyll plugin from papers.bib)
  const pubDataEl = document.getElementById('research-publications-data');
  const publications = pubDataEl ? JSON.parse(pubDataEl.textContent) : {};

  // Research areas and their relationships
  const data = {
    nodes: [
      // Current Focus
      { id: 'vlm', label: 'Vision-Language\nModels', period: 'current', description: 'Leveraging LLMs for computer vision without traditional pixel decoders' },
      { id: 'segmentation', label: 'Semantic\nSegmentation', period: 'current', description: 'Dense prediction and scene understanding at pixel level' },

      // Active Research
      { id: 'diffusion', label: 'Diffusion\nModels', period: 'active', description: 'Score-based generative models for image synthesis' },
      { id: 'gans', label: 'GANs', period: 'past', description: 'Generative adversarial networks for controllable generation' },
      { id: 'unlearning', label: 'Unlearning\n& Safety', period: 'active', description: 'Making AI systems safer through selective concept removal' },
      { id: 'debiasing', label: 'Fair\nGeneration', period: 'active', description: 'Debiasing generative models for equitable outputs' },

      // Past Work
      { id: 'ebm', label: 'Energy-Based\nModels', period: 'past', description: 'Learning energy functions for flexible probabilistic modeling' },
      { id: 'domain-gen', label: 'Domain\nGeneralization', period: 'past', description: 'Building models that generalize across unseen domains' },
      { id: 'few-shot', label: 'Few-Shot\nLearning', period: 'past', description: 'Learning from minimal labeled examples' },
      { id: 'localization', label: 'Indoor\nLocalization', period: 'past', description: 'Signal processing for indoor positioning systems' },
    ],
    links: [
      // Current connections
      { source: 'vlm', target: 'segmentation', strength: 1.5 },

      // Active research connections
      { source: 'diffusion', target: 'debiasing', strength: 1.3 },
      { source: 'gans', target: 'unlearning', strength: 1.3 },
      { source: 'diffusion', target: 'unlearning', strength: 1.0 },
      { source: 'gans', target: 'debiasing', strength: 0.8 },

      // Connections to past work
      { source: 'ebm', target: 'domain-gen', strength: 1.2 },
      { source: 'gans', target: 'few-shot', strength: 1.0 },
      { source: 'ebm', target: 'diffusion', strength: 0.9 },
      { source: 'gans', target: 'diffusion', strength: 0.8 },

      // Cross-period connections
      { source: 'vlm', target: 'diffusion', strength: 0.7 },
      { source: 'segmentation', target: 'domain-gen', strength: 0.6 },
      { source: 'few-shot', target: 'domain-gen', strength: 0.9 },
    ]
  };

  // Calculate node radius based on label text length
  function calculateNodeRadius(label) {
    const lines = label.split('\n');
    const charWidth = 6.2; // approximate char width at 11px font
    const lineHeight = 14;
    const paddingX = 16;
    const paddingY = 12;

    const maxLineWidth = Math.max(...lines.map(l => l.length * charWidth));
    const textHeight = lines.length * lineHeight;

    const radius = Math.max(maxLineWidth / 2 + paddingX, textHeight / 2 + paddingY);
    return Math.max(radius, 24); // minimum 24px
  }

  // Assign computed radii
  data.nodes.forEach(n => {
    n.radius = calculateNodeRadius(n.label);
  });

  // Dimensions
  const width = container.clientWidth;
  const height = Math.min(600, Math.max(450, width * 0.7));

  // Create SVG
  const svg = d3.select('#research-dna-viz')
    .append('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('viewBox', [0, 0, width, height]);

  // Defs for gradients and filters
  const defs = svg.append('defs');

  // Glow filter for current-focus nodes
  const glowFilter = defs.append('filter')
    .attr('id', 'glow')
    .attr('x', '-50%')
    .attr('y', '-50%')
    .attr('width', '200%')
    .attr('height', '200%');
  glowFilter.append('feGaussianBlur')
    .attr('stdDeviation', '3')
    .attr('result', 'coloredBlur');
  const feMerge = glowFilter.append('feMerge');
  feMerge.append('feMergeNode').attr('in', 'coloredBlur');
  feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

  // Add zoom behavior
  const g = svg.append('g');

  const zoom = d3.zoom()
    .scaleExtent([0.5, 3])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });

  svg.call(zoom);

  // Color scheme based on period
  const colorMap = {
    current: 'var(--global-theme-color)',
    active: 'var(--global-hover-color)',
    past: 'var(--global-text-color-light)'
  };

  // Force simulation with better parameters
  const simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.links)
      .id(d => d.id)
      .distance(d => 130 / (d.strength || 1))
      .strength(d => d.strength * 0.4)
    )
    .force('charge', d3.forceManyBody()
      .strength(-900)
      .distanceMax(350)
    )
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide()
      .radius(d => d.radius + 12)
      .strength(0.9)
    )
    .force('x', d3.forceX(width / 2).strength(0.05))
    .force('y', d3.forceY(height / 2).strength(0.05));

  // Create curved links
  const link = g.append('g')
    .attr('class', 'research-links-group')
    .selectAll('path')
    .data(data.links)
    .join('path')
    .attr('class', 'research-link')
    .attr('fill', 'none')
    .attr('stroke', 'var(--global-divider-color)')
    .attr('stroke-opacity', d => 0.3 + (d.strength * 0.2))
    .attr('stroke-width', d => 0.8 + d.strength * 1.2);

  // Create node groups
  const node = g.append('g')
    .attr('class', 'research-nodes-group')
    .selectAll('g')
    .data(data.nodes)
    .join('g')
    .attr('class', d => `research-node research-node--${d.period}`)
    .call(drag(simulation));

  // Add circles to nodes
  node.append('circle')
    .attr('r', d => d.radius)
    .attr('fill', d => colorMap[d.period])
    .attr('fill-opacity', d => d.period === 'current' ? 0.95 : 0.85)
    .attr('stroke', 'var(--global-bg-color)')
    .attr('stroke-width', 2.5)
    .attr('class', d => `node-circle node-${d.period}`)
    .attr('filter', d => d.period === 'current' ? 'url(#glow)' : null);

  // Add labels inside circles
  node.each(function(d) {
    const nodeGroup = d3.select(this);
    const lines = d.label.split('\n');
    const totalLines = lines.length;
    const lineHeight = 13;
    const startY = -(totalLines - 1) * lineHeight / 2;

    lines.forEach((line, i) => {
      nodeGroup.append('text')
        .attr('class', 'node-label')
        .attr('text-anchor', 'middle')
        .attr('x', 0)
        .attr('y', startY + i * lineHeight)
        .attr('dy', '0.35em')
        .text(line)
        .attr('fill', 'var(--global-bg-color)')
        .attr('font-size', '11px')
        .attr('font-weight', '600')
        .style('pointer-events', 'none');
    });
  });

  // Create tooltip
  const tooltip = d3.select(container)
    .append('div')
    .attr('class', 'research-tooltip')
    .style('opacity', 0);

  // Hover effects
  node
    .on('mouseenter', function(event, d) {
      const connectedNodes = new Set();
      connectedNodes.add(d.id);

      data.links.forEach(l => {
        if (l.source.id === d.id) connectedNodes.add(l.target.id);
        if (l.target.id === d.id) connectedNodes.add(l.source.id);
      });

      node.selectAll('.node-circle')
        .transition()
        .duration(200)
        .attr('fill-opacity', n => connectedNodes.has(n.id) ? 1 : 0.2)
        .attr('stroke-width', n => connectedNodes.has(n.id) ? 3.5 : 2);

      node.selectAll('.node-label')
        .transition()
        .duration(200)
        .style('opacity', function() {
          const parentData = d3.select(this.parentNode).datum();
          return connectedNodes.has(parentData.id) ? 1 : 0.2;
        });

      link
        .transition()
        .duration(200)
        .attr('stroke-opacity', l =>
          (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.05
        )
        .attr('stroke-width', l =>
          (l.source.id === d.id || l.target.id === d.id)
            ? (0.8 + l.strength * 1.2) * 1.5
            : 0.8 + l.strength * 1.2
        );

      // Scale up the hovered node
      d3.select(this).select('.node-circle')
        .transition()
        .duration(200)
        .attr('r', d.radius * 1.12);

      // Show tooltip
      tooltip
        .html(`<strong>${d.label.replace('\n', ' ')}</strong><br/><span>${d.description}</span>`)
        .style('opacity', 1);
    })
    .on('mousemove', function(event) {
      const containerRect = container.getBoundingClientRect();
      tooltip
        .style('left', (event.clientX - containerRect.left + 12) + 'px')
        .style('top', (event.clientY - containerRect.top - 10) + 'px');
    })
    .on('mouseleave', function() {
      node.selectAll('.node-circle')
        .transition()
        .duration(300)
        .attr('fill-opacity', d => d.period === 'current' ? 0.95 : 0.85)
        .attr('stroke-width', 2.5)
        .attr('r', d => d.radius);

      node.selectAll('.node-label')
        .transition()
        .duration(300)
        .style('opacity', 1);

      link
        .transition()
        .duration(300)
        .attr('stroke-opacity', d => 0.3 + (d.strength * 0.2))
        .attr('stroke-width', d => 0.8 + d.strength * 1.2);

      tooltip.style('opacity', 0);
    });

  // Click handler - show publications panel
  let selectedNodeId = null;
  const detailPanel = document.getElementById('research-detail-panel');

  node.on('click', function(event, d) {
    event.stopPropagation();
    const pubs = publications[d.id] || [];
    selectedNodeId = d.id;

    if (!detailPanel) return;

    const areaName = d.label.replace('\n', ' ');
    const periodLabels = { current: 'Current Focus', active: 'Active Research', past: 'Past Work' };

    let html = '<button class="detail-panel-close" aria-label="Close">&times;</button>';
    html += '<div class="detail-panel-header">';
    html += '<h4>' + areaName + '</h4>';
    html += '<span class="detail-panel-badge detail-panel-badge--' + d.period + '">' + periodLabels[d.period] + '</span>';
    html += '</div>';
    html += '<p class="detail-panel-desc">' + d.description + '</p>';

    if (pubs.length > 0) {
      html += '<div class="detail-panel-pubs">';
      html += '<h5>Related Publications</h5>';
      html += '<ul>';
      pubs.forEach(function(p) {
        html += '<li><a href="' + p.url + '" target="_blank" rel="noopener">' + p.title + '</a>';
        html += '<span class="pub-meta">' + p.venue + ' ' + p.year + '</span></li>';
      });
      html += '</ul>';
      html += '</div>';
    } else {
      html += '<p class="detail-panel-empty">No publications yet â€” this is an active area of exploration.</p>';
    }

    detailPanel.innerHTML = html;
    detailPanel.classList.add('visible');

    // Bind close button
    detailPanel.querySelector('.detail-panel-close').addEventListener('click', function() {
      detailPanel.classList.remove('visible');
      selectedNodeId = null;
    });
  });

  // Close panel when clicking SVG background
  svg.on('click', function() {
    if (detailPanel) {
      detailPanel.classList.remove('visible');
      selectedNodeId = null;
    }
  });

  // Curved link path generator
  function linkArc(d) {
    const dx = d.target.x - d.source.x;
    const dy = d.target.y - d.source.y;
    const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
  }

  // Update positions on tick
  simulation.on('tick', () => {
    link.attr('d', linkArc);
    node.attr('transform', d => `translate(${d.x},${d.y})`);
  });

  // Drag behavior
  function drag(simulation) {
    function dragstarted(event) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }

    return d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended);
  }

  // Responsive resize
  window.addEventListener('resize', function() {
    const newWidth = container.clientWidth;
    const newHeight = Math.min(600, Math.max(450, newWidth * 0.7));

    svg.attr('width', newWidth)
       .attr('height', newHeight)
       .attr('viewBox', [0, 0, newWidth, newHeight]);

    simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
    simulation.force('x', d3.forceX(newWidth / 2).strength(0.05));
    simulation.force('y', d3.forceY(newHeight / 2).strength(0.05));
    simulation.alpha(0.3).restart();
  });
});
