// Co-author Collaboration Network using D3.js
function initializeCoauthorNetwork() {
  const container = document.getElementById('coauthor-network-viz');
  if (!container) return;

  if (typeof d3 === 'undefined') {
    setTimeout(initializeCoauthorNetwork, 100);
    return;
  }

  fetch('/assets/json/coauthors.json')
    .then(response => {
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return response.json();
    })
    .then(data => {
      try {
        initializeVisualization(data);
      } catch (error) {
        container.innerHTML = '<p style="text-align: center; color: var(--global-text-color-light); padding: 2rem;">Error creating visualization.</p>';
      }
    })
    .catch(error => {
      container.innerHTML = '<p style="text-align: center; color: var(--global-text-color-light); padding: 2rem;">Unable to load collaboration network.</p>';
    });

  function initializeVisualization(data) {
    // Load author publication data from DOM (generated by Jekyll plugin from papers.bib)
    const authorPubDataEl = document.getElementById('author-publications-data');
    const rawAuthorPubs = authorPubDataEl ? JSON.parse(authorPubDataEl.textContent) : {};

    // Build normalized lookup: lowercase, remove dots/asterisks, sort words
    function normalizeAuthorName(name) {
      return name.toLowerCase().replace(/[.*]/g, '').trim().split(/\s+/).sort().join(' ');
    }
    const authorPublications = {};
    for (const [key, pubs] of Object.entries(rawAuthorPubs)) {
      authorPublications[key] = pubs; // already normalized from plugin
    }

    // Update paper counts from bib data
    data.nodes.forEach(n => {
      if (n.fullName) {
        const pubs = authorPublications[normalizeAuthorName(n.fullName)];
        if (pubs) n.papers = pubs.length;
      }
    });
    // Update link strengths to match actual paper counts
    data.links.forEach(l => {
      const srcNode = data.nodes.find(n => n.id === l.source);
      const tgtNode = data.nodes.find(n => n.id === l.target);
      if (srcNode && tgtNode && srcNode.fullName && tgtNode.fullName) {
        l.strength = Math.min(srcNode.papers, tgtNode.papers) || l.strength;
      }
    });

    const width = container.clientWidth;
    const height = Math.min(520, Math.max(400, width * 0.6));

    const svg = d3.select(container)
      .append('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height]);

    // Defs for glow filter
    const defs = svg.append('defs');
    const glowFilter = defs.append('filter')
      .attr('id', 'coauthor-glow')
      .attr('x', '-50%')
      .attr('y', '-50%')
      .attr('width', '200%')
      .attr('height', '200%');
    glowFilter.append('feGaussianBlur')
      .attr('stdDeviation', '3')
      .attr('result', 'coloredBlur');
    const feMerge = glowFilter.append('feMerge');
    feMerge.append('feMergeNode').attr('in', 'coloredBlur');
    feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

    const g = svg.append('g');

    const zoom = d3.zoom()
      .scaleExtent([0.5, 3])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom);

    // Node config - size based on type
    const nodeConfig = {
      primary: { color: 'var(--global-theme-color)', size: 32 },
      frequent: { color: 'var(--global-hover-color)', size: 24 },
      regular: { color: 'var(--global-text-color)', size: 20 },
      occasional: { color: 'var(--global-text-color-light)', size: 16 }
    };

    const links = data.links.map(d => Object.create(d));

    // Force simulation
    const simulation = d3.forceSimulation(data.nodes)
      .force('link', d3.forceLink(links)
        .id(d => d.id)
        .distance(d => 130 - (d.strength * 12))
        .strength(d => 0.2 + (d.strength * 0.06))
      )
      .force('charge', d3.forceManyBody()
        .strength(d => {
          if (d.id === 'you') return -350;
          if (d.type === 'frequent') return -800;
          return -600;
        })
        .distanceMax(350)
      )
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius(d => nodeConfig[d.type].size + 30)
        .strength(0.8)
      )
      .force('radial', d3.forceRadial(d => {
        if (d.id === 'you') return 0;
        if (d.type === 'frequent') return 140;
        if (d.type === 'regular') return 190;
        return 230;
      }, width / 2, height / 2).strength(0.12));

    simulation.alpha(1).alphaDecay(0.015);

    // Create curved links
    const link = g.append('g')
      .selectAll('path')
      .data(data.links)
      .join('path')
      .attr('class', 'coauthor-link')
      .attr('fill', 'none')
      .attr('stroke', 'var(--global-divider-color)')
      .attr('stroke-opacity', d => 0.4 + (d.strength * 0.1))
      .attr('stroke-width', d => 1 + (d.strength * 1.2));

    // Create node groups
    const node = g.append('g')
      .selectAll('g')
      .data(data.nodes, d => d.id)
      .join('g')
      .attr('class', 'coauthor-node')
      .call(drag(simulation));

    // Add circles
    node.append('circle')
      .attr('r', d => nodeConfig[d.type].size)
      .attr('fill', d => nodeConfig[d.type].color)
      .attr('fill-opacity', d => d.type === 'primary' ? 0.95 : 0.85)
      .attr('stroke', 'var(--global-bg-color)')
      .attr('stroke-width', 2.5)
      .attr('class', d => `node-circle node-${d.type}`)
      .attr('filter', d => d.type === 'primary' ? 'url(#coauthor-glow)' : null);

    // Add labels below circles for better readability
    node.each(function(nodeData) {
      const nodeGroup = d3.select(this);
      const lines = nodeData.label.split('\n');
      const circleR = nodeConfig[nodeData.type].size;

      lines.forEach((line, i) => {
        nodeGroup.append('text')
          .attr('class', 'coauthor-label')
          .attr('text-anchor', 'middle')
          .attr('x', 0)
          .attr('y', circleR + 14 + (i * 13))
          .text(line)
          .attr('fill', 'var(--global-text-color)')
          .attr('font-size', nodeData.type === 'primary' ? '12px' : '10px')
          .attr('font-weight', '600')
          .style('pointer-events', 'none');
      });
    });

    // Add paper count badges
    node.append('circle')
      .attr('class', 'paper-badge')
      .attr('r', 10)
      .attr('cx', d => nodeConfig[d.type].size * 0.7)
      .attr('cy', d => -nodeConfig[d.type].size * 0.7)
      .attr('fill', 'var(--global-theme-color)')
      .attr('stroke', 'var(--global-bg-color)')
      .attr('stroke-width', 2)
      .style('display', d => d.papers > 0 ? 'block' : 'none');

    node.append('text')
      .attr('class', 'paper-count')
      .attr('x', d => nodeConfig[d.type].size * 0.7)
      .attr('y', d => -nodeConfig[d.type].size * 0.7)
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('fill', 'var(--global-bg-color)')
      .attr('font-size', '9px')
      .attr('font-weight', 'bold')
      .text(d => d.papers)
      .style('display', d => d.papers > 0 ? 'block' : 'none')
      .style('pointer-events', 'none');

    // Create tooltip
    const tooltip = d3.select(container)
      .append('div')
      .attr('class', 'coauthor-tooltip')
      .style('opacity', 0);

    // Hover effects
    node
      .on('mouseenter', function(event, d) {
        const connectedIds = new Set();
        connectedIds.add(d.id);

        links.forEach(l => {
          if (l.source === d.id || (typeof l.source === 'object' && l.source.id === d.id)) {
            connectedIds.add(typeof l.target === 'object' ? l.target.id : l.target);
          }
          if (l.target === d.id || (typeof l.target === 'object' && l.target.id === d.id)) {
            connectedIds.add(typeof l.source === 'object' ? l.source.id : l.source);
          }
        });

        node.selectAll('.node-circle')
          .transition()
          .duration(200)
          .attr('fill-opacity', n => connectedIds.has(n.id) ? 1 : 0.2)
          .attr('stroke-width', n => connectedIds.has(n.id) ? 3.5 : 2);

        node.selectAll('.coauthor-label')
          .transition()
          .duration(200)
          .style('opacity', function() {
            const parentData = d3.select(this.parentNode).datum();
            return connectedIds.has(parentData.id) ? 1 : 0.2;
          });

        link
          .transition()
          .duration(200)
          .attr('stroke-opacity', l =>
            (l.source.id === d.id || l.target.id === d.id) ? 0.8 : 0.05
          );

        d3.select(this).select('.node-circle')
          .transition()
          .duration(200)
          .attr('r', nodeConfig[d.type].size * 1.15);

        // Show tooltip
        const paperText = d.papers > 0 ? `${d.papers} paper${d.papers > 1 ? 's' : ''} together` : '';
        tooltip
          .html(`<strong>${d.fullName}</strong>${paperText ? '<br/><span>' + paperText + '</span>' : ''}`)
          .style('opacity', 1);
      })
      .on('mousemove', function(event) {
        const containerRect = container.getBoundingClientRect();
        tooltip
          .style('left', (event.clientX - containerRect.left + 12) + 'px')
          .style('top', (event.clientY - containerRect.top - 10) + 'px');
      })
      .on('mouseleave', function(event, d) {
        node.selectAll('.node-circle')
          .transition()
          .duration(300)
          .attr('fill-opacity', n => n.type === 'primary' ? 0.95 : 0.85)
          .attr('stroke-width', 2.5)
          .attr('r', n => nodeConfig[n.type].size);

        node.selectAll('.coauthor-label')
          .transition()
          .duration(300)
          .style('opacity', 1);

        link
          .transition()
          .duration(300)
          .attr('stroke-opacity', l => 0.4 + (l.strength * 0.1));

        tooltip.style('opacity', 0);
      });

    // Click handler - show publications panel
    let selectedNodeId = null;
    const detailPanel = document.getElementById('coauthor-detail-panel');

    node.on('click', function(event, d) {
      event.stopPropagation();
      if (!detailPanel) return;

      const normalized = normalizeAuthorName(d.fullName);
      const pubs = authorPublications[normalized] || [];
      selectedNodeId = d.id;

      const typeLabels = {
        primary: 'You',
        frequent: 'Frequent Collaborator',
        regular: 'Regular Collaborator',
        occasional: 'Occasional Collaborator'
      };

      let html = '<button class="detail-panel-close" aria-label="Close">&times;</button>';
      html += '<div class="detail-panel-header">';
      html += '<h4>' + d.fullName + '</h4>';
      if (d.type !== 'primary') {
        html += '<span class="detail-panel-badge detail-panel-badge--' +
          (d.type === 'frequent' ? 'current' : d.type === 'regular' ? 'active' : 'past') +
          '">' + typeLabels[d.type] + '</span>';
      }
      html += '</div>';

      if (pubs.length > 0) {
        html += '<div class="detail-panel-pubs">';
        html += '<h5>' + (d.type === 'primary' ? 'All Publications' : 'Joint Publications') + '</h5>';
        html += '<ul>';
        pubs.forEach(function(p) {
          html += '<li><a href="' + p.url + '" target="_blank" rel="noopener">' + p.title + '</a>';
          html += '<span class="pub-meta">' + p.venue + ' ' + p.year + '</span></li>';
        });
        html += '</ul>';
        html += '</div>';
      } else {
        html += '<p class="detail-panel-empty">No publications found in bibliography.</p>';
      }

      detailPanel.innerHTML = html;
      detailPanel.classList.add('visible');

      detailPanel.querySelector('.detail-panel-close').addEventListener('click', function() {
        detailPanel.classList.remove('visible');
        selectedNodeId = null;
      });
    });

    // Close panel when clicking SVG background
    svg.on('click', function() {
      if (detailPanel) {
        detailPanel.classList.remove('visible');
        selectedNodeId = null;
      }
    });

    // Curved link path
    function linkArc(d) {
      const dx = d.target.x - d.source.x;
      const dy = d.target.y - d.source.y;
      const dr = Math.sqrt(dx * dx + dy * dy) * 1.8;
      return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    }

    // Update positions on tick
    simulation.on('tick', () => {
      link.attr('d', linkArc);
      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Drag behavior
    function drag(simulation) {
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }

      return d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);
    }

    // Responsive resize
    window.addEventListener('resize', function() {
      const newWidth = container.clientWidth;
      const newHeight = Math.min(520, Math.max(400, newWidth * 0.6));

      svg.attr('width', newWidth)
         .attr('height', newHeight)
         .attr('viewBox', [0, 0, newWidth, newHeight]);

      simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
      simulation.force('radial', d3.forceRadial(d => {
        if (d.id === 'you') return 0;
        if (d.type === 'frequent') return 140;
        if (d.type === 'regular') return 190;
        return 230;
      }, newWidth / 2, newHeight / 2).strength(0.12));
      simulation.alpha(0.3).restart();
    });
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeCoauthorNetwork);
} else {
  initializeCoauthorNetwork();
}
