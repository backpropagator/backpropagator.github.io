<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Pondering upon Eigenvectors | Piyush Tiwary</title> <meta name="author" content="Piyush Tiwary"> <meta name="description" content="basics of eigenvectors/eigenvalues"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://backpropagator.github.io/blog/2020/eigenvector/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-DP8LD8Z4LH"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DP8LD8Z4LH");</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Piyush </span>Tiwary</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Pondering upon Eigenvectors</h1> <p class="post-meta">June 17, 2020</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/tag/math"> <i class="fas fa-hashtag fa-sm"></i> math,</a>   <a href="/blog/tag/basics"> <i class="fas fa-hashtag fa-sm"></i> basics</a>     ·   <a href="/blog/category/math"> <i class="fas fa-tag fa-sm"></i> math</a>   </p> </header> <article class="post-content"> <h2 id="table-of-contents">Table of Contents</h2> <ul> <li><a href="#matrix-as-transformations">Matrix as Transformations!</a></li> <li><a href="#what-are-these-eigen-things">What are these “Eigen” things?</a></li> <li><a href="#some-things-to-look-for">Some things to look for</a></li> <li><a href="#so-why-do-they-pop-up-everywhere">So why do they pop up everywhere?</a></li> <li> <a href="#computational-methods-for-eigenvalues-and-eigenvectors">Computational Methods for Eigenvalues and Eigenvectors</a> <ul> <li><a href="#power-method">Power Method</a></li> <li><a href="#qr-algorithm">QR Algorithm</a></li> <li><a href="#jacobi-method">Jacobi Method</a></li> <li><a href="#krylov-subspace-methods">Krylov Subspace Methods</a></li> <li><a href="#divide-and-conquer-approaches">Divide and Conquer Approaches</a></li> <li><a href="#numerical-considerations">Numerical Considerations</a></li> </ul> </li> <li> <a href="#real-world-applications-of-eigenvectors-and-eigenvalues">Real-World Applications of Eigenvectors and Eigenvalues</a> <ul> <li><a href="#principal-component-analysis-pca">Principal Component Analysis (PCA)</a></li> <li><a href="#googles-pagerank-algorithm">Google’s PageRank Algorithm</a></li> <li><a href="#markov-chains-and-steady-states">Markov Chains and Steady States</a></li> <li><a href="#vibration-analysis-in-engineering">Vibration Analysis in Engineering</a></li> <li><a href="#quantum-mechanics">Quantum Mechanics</a></li> </ul> </li> <li><a href="#footnotes">Footnotes</a></li> </ul> <p>The Eigenvectors &amp; Eigenvalues pop up in many places of mathematical analysis and application. For example: Machine Learning, Control Theory, Signal Processing, Quantum Physics, Markov Process just to name a few! Despite their wide applications, it isn’t entirely clear as to what these Eigenvectors represent and what is their significance in all these applications. Also, many students see Eigenvectors as a bunch of steps to find a vector which is going to help them, and hence they have very little intuition about them. In this post, I plan to give an intuition of the same and also provide some insights of how they are calculated algorithmically.</p> <h2 id="matrix-as-transformations">Matrix as Transformations!</h2> <p>Well to understand this, we need to understand what a <strong>“Matrix”</strong> is? Generally, matrices are seen as a bunch of numbers inside a box used to perform collective operations. It’s one way to look at it. But a higher level insight is to look at matrices as a <strong>Transformation</strong>!</p> <p>Let’s take an example, let \(A = \left( \begin{array}{cc} 1 &amp; 0 \\ 0 &amp; 1 \end{array} \right)\). If we multiply any vector \(\alpha = \left( \begin{array}{c} \alpha_1 \\ \alpha_2 \\ \end{array} \right)\) with \(A\), we’ll get the same vector. Not interesting right?</p> <p>But here is where it gets interesting, we can look at this multiplication in 2 ways. One way is the traditional method of matrix multiplication:</p> \[A\alpha = \left( \begin{array}{cc} 1 &amp; 0 \\ 0 &amp; 1 \end{array} \right) \left( \begin{array}{c} \alpha_1 \\ \alpha_2 \end{array} \right) = \left( \begin{array}{c} (1*\alpha_1) + (0*\alpha_2) \\ (0*\alpha_1) + (1*\alpha_2) \end{array} \right)\] <p>But there’s another way to look at it, instead of multiplying rows by columns, we can multiply columns by scalar values, here’s what I mean:</p> \[A\alpha = \left( \begin{array}{c} 1 \\ 0 \\ \end{array} \right)\alpha_1 + \left( \begin{array}{c} 0 \\ 1 \\ \end{array} \right)\alpha_2\] <p>From this way of multiplication, we can see that this multiplication is essentially addition of two separate column vectors, where each column vector is obtained by taking the columns of \(A\) and <strong>scaling</strong> them by elements of \(\alpha\)! In other words, if we want to find the product of a matrix with a vector, just take the columns of the matrix, scale them by corresponding amount in the vector and sum them up. So, we scale the first column by \(\alpha_1\) and second column by \(\alpha_2\) and add them up.</p> <p>Does this seem familiar? If you were thinking of Vectors, you are right! This highlights an important aspect of a Matrix: <strong>when the columns of a Matrix are linearly independent, they form a basis for the range (image) of the Matrix</strong>. These vectors are also called <strong>Basis Vectors</strong>.</p> <p>Going back to our example, the columns of \(A\): \(\left( \begin{array}{c} 1 \\ 0 \\ \end{array} \right)\) &amp; \(\left( \begin{array}{c} 0 \\ 1 \\ \end{array} \right)\) in a way, represent the directions in which we need to travel to get our answer (the product), so you need to go \(\alpha_1\) amount in the direction of \(\left( \begin{array}{c} 1 \\ 0 \\ \end{array} \right)\) and \(\alpha_2\) amount in the direction of \(\left( \begin{array}{c} 0 \\ 1 \\ \end{array} \right)\) to get the product \(A\alpha\).</p> <p>In terms of vectors, one can interpret the columns of matrix as vector directions of \(\hat i\) &amp; \(\hat j\) and the multiplication \(A\alpha\) is nothing but the vector \(\alpha_1 \hat i + \alpha_2 \hat j\).</p> <p>Cool! but what if the matrix isn’t trivial like this one? say \(A = \left( \begin{array}{cc} x_1 &amp; x_2 \\ y_1 &amp; y_2 \\ \end{array} \right)\) this makes a very little difference. Instead of the component directions being \(\hat i\) &amp; \(\hat j\), the direction of each column will be \((x_1 \hat i + y_1 \hat j)\) &amp; \((x_2 \hat i + y_2 \hat j)\) respectively. And the product \(A \alpha\) is nothing but \(\alpha_1 (x_1 \hat i + y_1 \hat j) + \alpha_2 (x_2 \hat i + y_2 \hat j)\)! This is really a nice way to look at matrix multiplications which relate Matrices to Vectors in such an intuitive way!</p> <p>Now, where is transformation in all this? For this we need to look at \(\alpha\).</p> <p>Any \(\alpha\) with dimension \((2 \times 1)\) can represent a point in 2-dimension. So, \(\alpha \in \mathbb{R}^2\) and after multiplying by \(A\), the product \(A\alpha \in \mathbb{R}^2\) too. So, we can say that \(A\) maps a vector from \(\mathbb{R}^2\) to \(\mathbb{R}^2\), <strong>but is it the same Coordinate System?</strong> The answer is <strong>No!</strong> the coordinate system has changed indeed but how? Think of it this way - originally, \(\alpha\) was in original \(2D\) plane whose axis were \(\left( \begin{array}{c} 1 \\ 0 \\ \end{array} \right)\) &amp; \(\left( \begin{array}{c} 0 \\ 1 \\ \end{array} \right)\) (or \(\hat i\) &amp; \(\hat j\)), so to go to any point we need to go some distance along \(\hat i\) and some distance along \(\hat j\), but after multiplying it by \(A\), the axis are changed to \(\left( \begin{array}{c} x_1 \\ y_1 \\ \end{array} \right)\) &amp; \(\left( \begin{array}{c} x_2 \\ y_2 \\ \end{array} \right)\) (or \((x_1 \hat i + y_1 \hat j)\) &amp; \((x_2 \hat i + y_2 \hat j)\)). So, can you see the transformation? The axis of the coordinate system is changed after multiplying with a matrix. More clearly:</p> <p>\(\left( \begin{array}{c} 1 \\ 0 \\ \end{array} \right) \rightarrow \left( \begin{array}{c} x_1 \\ y_1 \\ \end{array} \right)\)    &amp;    \(\left( \begin{array}{c} 0 \\ 1 \\ \end{array} \right) \rightarrow \left( \begin{array}{c} x_2 \\ y_2 \\ \end{array} \right)\)</p> <p>In literature these axes are also called <strong>Basis Vectors</strong>. Basis of a vector space is a set of linearly independent vectors through which we can get any vector in that space by taking some linear combination of these vectors. There’s more to this, but I leave it to the reader to explore for themselves.</p> <h2 id="what-are-these-eigen-things">What are these “Eigen” things?</h2> <p>Having an intuition of how matrix can be seen as a Transformation, we are in a position to understand the Eigenvectors &amp; Eigenvalues.</p> <p>So, while transforming a point from one basis to another by multiplication of a matrix, we map a point in the original 2D plane to some other point in the transformed plane. If we look at the vectors representing these points, they are also being transformed from one coordinate system to another. However, <strong>there are some vectors that don’t change their direction, instead they only get scaled up or scaled down!</strong> These vectors are nothing but the Eigenvectors! and the amount by which they get scaled up or down is the corresponding Eigenvalue!</p> <p>Mathematically, these are the vectors that after multiplying by \(A\) get scaled up or down but the direction remains the same. For equation form we need, \(Ax\) which is in the same direction as \(x\) but scaled up or down (let’s say by \(\lambda\)). So,</p> \[Ax = \lambda x\] <p>Which is the equation we have been taught to calculate the eigenvectors &amp; eigenvalues. From this equation, we can find the Eigenvalues of A by solving</p> \[|A - \lambda\mathbb{I}| = 0\] <p>To find the eigenvectors, we will have to find the Basis of Null-Space of \(A - \lambda\mathbb{I}\) for each eigenvalue \(\lambda\). The Null Space of a matrix \(A\) (also written as \(N(A)\)) contains all the vectors \(x\) such that, \(Ax=0\), so finding basis of \(N(A-\lambda\mathbb{I})\) means that we have to find basis of all the vectors for which \((A - \lambda\mathbb{I})x = 0\) which is the definition of Eigenvectors.</p> <h2 id="some-things-to-look-for">Some things to look for</h2> <p>Okay! so up to this point we have understood what is the physical significance of Eigenvectors. Now there are some things we should be aware of. Let’s first define some terms.</p> <p><strong>Span</strong>: The <strong>span</strong> of a set of vectors is the set of all Linear Combinations of the vectors. Implicitly, Span indicates the dimension that can be covered by using a set of vectors.</p> <p><strong>Rank</strong>: Rank of a matrix is defined as the maximum number of linearly independent columns (or rows) in a matrix. This is the textbook definition of Rank. Its physical significance is that, Rank of a matrix denotes the dimension of the range (image) of the linear transformation. To understand this, let’s take an example</p> \[A = \left( \begin{array}{ccc} 1 &amp; 2 &amp; 5 \\ 3 &amp; 5 &amp; 13 \\ 7 &amp; 6 &amp; 19 \\ \end{array} \right)\] <p>So, if a vector of dimension \((3 \times 1)\) is multiplied by A, we’ll get a \((3 \times 1)\) vector. Seems nice! It looks like \(A\) produces a vector in 3D. But, it’s not necessarily the case! if we look carefully, then we can see that, there are only 2 independent columns in \(A\)!</p> \[C_3 = C_1 + 2C_2\] <p>where \(C_1, C_2\) &amp; \(C_3\) are the columns of \(A\).</p> <p>So, what this means is, these 3 columns/vectors are <strong>Coplanar</strong>, so taking any linear combination of these vectors would give us a point in this plane itself! So, the Span of the columns is \(\mathbb{R}^2\) and not \(\mathbb{R}^3\)! We can also see this by a simple calculation, take any linear combination of columns of \(A\):</p> \[C = \alpha_1 C_1 + \alpha_2 C_2 + \alpha_3 C_3\] <p>Using the fact that \(C_3 = C_1 + 2C_2\):</p> \[\begin{align} C &amp;= \alpha_1 C_1 + \alpha_2 C_2 + \alpha_3 (C_1 + 2C_2) \\ &amp;= (\alpha_1 + \alpha_3) C_1 + (\alpha_2 + 2 \alpha_3) C_2 \\ &amp;= \beta_1 C_1 + \beta_2 C_2 \end{align}\] <p>So, though it looks like \(A\) maps a vector to \(\mathbb{R}^3\) but, it actually maps it to a subspace of dimension 2. Hence, rank of the matrix is 2!</p> <p>That being said, let’s try to visualize the transformation this matrix is performing. The input space is \(\mathbb{R}^3\) and the output space is a 2-dimensional subspace of \(\mathbb{R}^3\), this means that the transformation, in some way, squashes a dimension of the 3D system.</p> <p>It’s important to note that there is a relationship between the rank of a matrix and its eigenvalues and eigenvectors, but it’s not as simple as “the number of non-zero eigenvectors equals the rank.” Instead:</p> <ol> <li> <p>For an \(n \times n\) matrix, the dimension of the eigenspace corresponding to the eigenvalue 0 (if it exists) equals the nullity of the matrix (dimension of the null space), which is \(n - \text{rank}(A)\).</p> </li> <li> <p>A matrix can have up to \(n\) linearly independent eigenvectors, regardless of its rank.</p> </li> <li> <p>If a matrix has \(n\) distinct eigenvalues, it will have \(n\) linearly independent eigenvectors.</p> </li> </ol> <h2 id="so-why-do-they-pop-up-everywhere">So why do they pop up everywhere?</h2> <p>Well simply put, Eigenvectors make understanding/visualizing Linear transforms easier! We can analyze any Linear transform as stretching or compressing of certain vectors. Which makes things much easier, and for diagonalizable matrices, we can always decompose a matrix in terms of its eigenvectors &amp; eigenvalues:</p> \[A = V \Lambda V^{-1}\] <p>where \(V\) is the matrix containing Eigenvectors as columns &amp; \(\Lambda\) is a Diagonal matrix with Eigenvalues as the diagonal values. This Factorization is also called <strong>Eigenvalue decomposition</strong>, which is heavily used in Control Theory &amp; Signal Processing.</p> <p>It’s worth noting that not all matrices are diagonalizable. A matrix is diagonalizable if and only if it has enough linearly independent eigenvectors to form a basis for the space. Specifically, an \(n \times n\) matrix is diagonalizable if and only if the sum of the dimensions of its eigenspaces equals \(n\).</p> <h2 id="computational-methods-for-eigenvalues-and-eigenvectors">Computational Methods for Eigenvalues and Eigenvectors</h2> <p>While the theoretical foundation of eigenvectors and eigenvalues provides insight into their mathematical properties, computing them for practical applications requires efficient numerical algorithms. Here, we explore the primary computational methods used to calculate eigenvalues and eigenvectors, particularly for large matrices where direct calculation is infeasible.</p> <h3 id="power-method">Power Method</h3> <p>The simplest iterative approach for finding the dominant eigenvalue (largest in magnitude) and its corresponding eigenvector is the power method.</p> <p>Given a matrix \(A \in \mathbb{R}^{n \times n}\), the algorithm works as follows:</p> <ol> <li>Start with an initial guess vector \(\mathbf{x}_0\), typically random but nonzero</li> <li>Perform iterations: \(\mathbf{y}_{k+1} = A\mathbf{x}_k\) \(\mathbf{x}_{k+1} = \frac{\mathbf{y}_{k+1}}{\|\mathbf{y}_{k+1}\|}\)</li> <li>The sequence \(\{\mathbf{x}_k\}\) converges to the eigenvector corresponding to the dominant eigenvalue</li> <li>The dominant eigenvalue can be estimated using the Rayleigh quotient: \(\lambda \approx \frac{\mathbf{x}_k^T A \mathbf{x}_k}{\mathbf{x}_k^T \mathbf{x}_k}\)</li> </ol> <p>For convergence, the matrix must have a dominant eigenvalue \(\lambda_1\) such that \(\mid\lambda_1\mid &gt; \mid\lambda_2\mid \geq \mid\lambda_3\mid \geq \cdots \geq \mid\lambda_n\mid\). The rate of convergence depends on the ratio \(\mid\frac{\lambda_2}{\lambda_1}\mid\)—the smaller this ratio, the faster the convergence.</p> <p>A variant called the inverse power method can find the smallest eigenvalue by applying the power method to \(A^{-1}\):</p> \[\mathbf{y}_{k+1} = A^{-1}\mathbf{x}_k\] <p>In practice, we solve the system \(A\mathbf{y}_{k+1} = \mathbf{x}_k\) rather than explicitly computing the inverse.</p> <p>The shifted inverse power method can target eigenvalues near a specific value \(\mu\) by applying the inverse power method to \((A - \mu I)\):</p> \[\mathbf{y}_{k+1} = (A - \mu I)^{-1}\mathbf{x}_k\] <h3 id="qr-algorithm">QR Algorithm</h3> <p>The QR algorithm is a more robust method that can compute all eigenvalues of a matrix. It works by performing a sequence of QR decompositions:</p> <ol> <li>Initialize \(A_0 = A\)</li> <li>For \(k = 0, 1, 2, \ldots\): <ul> <li>Compute the QR decomposition \(A_k = Q_k R_k\) where \(Q_k\) is orthogonal and \(R_k\) is upper triangular</li> <li>Set \(A_{k+1} = R_k Q_k\) (note the order reversal)</li> </ul> </li> </ol> <p>As \(k \to \infty\), \(A_k\) converges to a Schur form, with eigenvalues appearing on the diagonal.</p> <p>For computational efficiency, the matrix is first reduced to Hessenberg form (upper triangular plus one subdiagonal) using Householder reflections:</p> \[A = PHP^T\] <p>where \(P\) is orthogonal and \(H\) is in Hessenberg form. This preliminary step reduces the QR decomposition cost from \(O(n^3)\) to \(O(n^2)\) per iteration.</p> <p>The QR algorithm with shifts further accelerates convergence:</p> <ol> <li>Choose a shift \(\mu_k\) (often the Wilkinson shift or the Rayleigh quotient shift)</li> <li>Compute \((A_k - \mu_k I) = Q_k R_k\)</li> <li>Set \(A_{k+1} = R_k Q_k + \mu_k I\)</li> </ol> <p>The implicit QR algorithm avoids explicitly forming \((A_k - \mu_k I)\) and operates directly on the Hessenberg matrix, making it numerically more stable.</p> <h3 id="jacobi-method">Jacobi Method</h3> <p>For symmetric matrices, the Jacobi method is an intuitive approach that works by eliminating off-diagonal elements through a sequence of plane rotations:</p> <ol> <li>Initialize \(A_0 = A\) and \(V_0 = I\) (identity matrix)</li> <li>At each step \(k\), identify the largest off-diagonal element \(a_{ij}^{(k)}\)</li> <li>Compute the rotation angle \(\theta\) to zero out this element: \(\tan(2\theta) = \frac{2a_{ij}^{(k)}}{a_{ii}^{(k)} - a_{jj}^{(k)}}\)</li> <li>Construct the rotation matrix \(J\) (Jacobi rotation)</li> <li>Update \(A_{k+1} = J^T A_k J\) and \(V_{k+1} = V_k J\)</li> </ol> <p>The process continues until the off-diagonal elements are sufficiently small. At convergence, \(A_k\) contains the eigenvalues on the diagonal, and \(V_k\) contains the eigenvectors as columns.</p> <p>For an \(n \times n\) matrix, each sweep (\(n(n-1)/2\) rotations) reduces the sum of squares of off-diagonal elements by a factor dependent on the matrix properties.</p> <h3 id="krylov-subspace-methods">Krylov Subspace Methods</h3> <p>For very large sparse matrices, Krylov subspace methods like the Arnoldi and Lanczos algorithms are preferred. These methods work by projecting the matrix onto a lower-dimensional Krylov subspace:</p> \[\mathcal{K}_m(A, \mathbf{v}) = \text{span}\{\mathbf{v}, A\mathbf{v}, A^2\mathbf{v}, \ldots, A^{m-1}\mathbf{v}\}\] <p>The Arnoldi iteration builds an orthonormal basis for this subspace and produces a Hessenberg matrix \(H_m\) such that:</p> \[AV_m = V_m H_m + \beta_m\mathbf{v}_{m+1}\mathbf{e}_m^T\] <p>where \(V_m\) is the matrix whose columns are the orthonormal basis vectors.</p> <p>The eigenvalues of \(H_m\) (Ritz values) approximate some eigenvalues of \(A\), often the ones with largest magnitude. The corresponding eigenvectors (Ritz vectors) are given by \(V_m\mathbf{y}\) where \(\mathbf{y}\) is an eigenvector of \(H_m\).</p> <p>For symmetric matrices, the Lanczos algorithm simplifies the Arnoldi process, as \(H_m\) becomes tridiagonal. This reduces the computation and storage requirements significantly:</p> \[AV_m = V_m T_m + \beta_m\mathbf{v}_{m+1}\mathbf{e}_m^T\] <p>where \(T_m\) is a tridiagonal matrix.</p> <h3 id="divide-and-conquer-approaches">Divide and Conquer Approaches</h3> <p>For symmetric tridiagonal matrices, divide-and-conquer algorithms provide efficient solutions by:</p> <ol> <li>Dividing the matrix into smaller submatrices</li> <li>Computing eigenvalues and eigenvectors of these subproblems</li> <li>Merging the results to obtain solutions for the original problem</li> </ol> <p>The merging step requires solving a secular equation of the form:</p> \[f(\lambda) = 1 + \sum_{i=1}^{n} \frac{\rho_i^2}{\delta_i - \lambda} = 0\] <p>where \(\delta_i\) are the eigenvalues from subproblems and \(\rho_i\) are derived from the rank-one update that combines the subproblems.</p> <p>This approach achieves \(O(n^2)\) complexity and excellent parallelizability.</p> <h3 id="numerical-considerations">Numerical Considerations</h3> <p>Several practical considerations affect eigenvalue calculations:</p> <ol> <li> <p><strong>Conditioning</strong>: The sensitivity of eigenvalues to perturbations is measured by the condition number. For a simple eigenvalue \(\lambda\) with right eigenvector \(\mathbf{x}\) and left eigenvector \(\mathbf{y}\), the condition number is:</p> \[\kappa(\lambda) = \frac{|\mathbf{y}^T\mathbf{x}|}{|\mathbf{y}||\mathbf{x}|}\] <p>A large condition number indicates high sensitivity.</p> </li> <li> <p><strong>Balancing</strong>: Scaling the matrix to reduce its norm can improve numerical stability:</p> \[P^{-1}AP = B\] <p>where \(P\) is a diagonal matrix chosen to minimize \(\|B\|_F\).</p> </li> <li> <p><strong>Deflation</strong>: Once an eigenvalue-eigenvector pair \((\lambda, \mathbf{x})\) is found, we can deflate the matrix to focus on finding the remaining eigenvalues:</p> \[A' = A - \lambda \mathbf{x}\mathbf{y}^T\] <p>where \(\mathbf{y}\) is the normalized left eigenvector.</p> </li> <li> <p><strong>Stopping criteria</strong>: Practical implementations need robust criteria to determine when an eigenvalue has converged. Common approaches include:</p> \[\frac{\|A\mathbf{x} - \lambda\mathbf{x}\|}{\|A\|\|\mathbf{x}\|} &lt; \epsilon\] <p>or examining the magnitude of subdiagonal elements in the Hessenberg/tridiagonal matrix.</p> </li> </ol> <p>Modern eigenvalue libraries like LAPACK implement sophisticated versions of these algorithms with numerous optimizations for efficiency and numerical stability. For extremely large sparse matrices encountered in scientific computing, specialized packages like ARPACK leverage Krylov subspace methods with implicit restarting to efficiently compute selected eigenvalues.</p> <h2 id="real-world-applications-of-eigenvectors-and-eigenvalues">Real-World Applications of Eigenvectors and Eigenvalues</h2> <p>Now that we understand the theoretical aspects of eigenvectors and eigenvalues, let’s explore some fascinating real-world applications where these concepts play a crucial role. We’ll examine the mathematical foundations behind each application.</p> <h3 id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h3> <p>In data science and machine learning, PCA is a dimensionality reduction technique that helps simplify complex datasets while preserving as much information as possible.</p> <p>Mathematically, given a data matrix \(X \in \mathbb{R}^{n \times p}\) with \(n\) observations and \(p\) features, we:</p> <ol> <li> <p>Center the data by subtracting the mean: \(\tilde{X} = X - \bar{X}\)</p> </li> <li> <p>Compute the covariance matrix \(\Sigma\): \(\Sigma = \frac{1}{n-1} \tilde{X}^T \tilde{X}\)</p> </li> <li> <p>Find the eigendecomposition of \(\Sigma\): \(\Sigma = V \Lambda V^T\) where \(V\) contains eigenvectors and \(\Lambda\) contains eigenvalues \(\lambda_1 \geq \lambda_2 \geq ... \geq \lambda_p \geq 0\)</p> </li> <li> <p>The principal components are given by: \(Y = \tilde{X}V\)</p> </li> <li> <p>For dimensionality reduction, we select the first \(k\) eigenvectors (columns of \(V\)) corresponding to the \(k\) largest eigenvalues: \(Y_k = \tilde{X}V_k\) where \(V_k\) consists of the first \(k\) columns of \(V\).</p> </li> </ol> <p>The proportion of variance explained by the first \(k\) components is: \(\frac{\sum_{i=1}^{k} \lambda_i}{\sum_{i=1}^{p} \lambda_i}\)</p> <p>In facial recognition, eigenfaces (eigenvectors of face image datasets) capture the most distinctive facial features that help differentiate between individuals.</p> <h3 id="googles-pagerank-algorithm">Google’s PageRank Algorithm</h3> <p>The original algorithm behind Google’s search engine utilizes eigenvector centrality to rank web pages.</p> <p>Let’s define:</p> <ul> <li>\(n\) = number of web pages</li> <li>\(A\) = adjacency matrix where \(A_{ij} = 1\) if page \(j\) links to page \(i\), and 0 otherwise</li> <li>\(D\) = diagonal matrix where \(D_{jj}\) = outdegree of page \(j\) (number of outgoing links)</li> </ul> <p>The stochastic transition matrix \(P\) is given by: \(P = AD^{-1}\)</p> <p>However, to handle pages with no outgoing links (dangling nodes) and to ensure convergence, the PageRank matrix \(G\) is modified with a damping factor \(\alpha\) (typically 0.85):</p> \[G = \alpha P + (1-\alpha) \frac{1}{n} \mathbf{1}\mathbf{1}^T\] <p>where \(\mathbf{1}\) is an \(n \times 1\) vector of ones.</p> <p>The PageRank vector \(\pi\) is the dominant eigenvector of \(G\): \(G\pi = \pi\)</p> <p>Equivalently, it’s the solution to: \(\pi^T = \pi^T G\) subject to \(\sum_{i=1}^{n} \pi_i = 1\) and \(\pi_i \geq 0\) for all \(i\).</p> <p>This can be computed iteratively: \(\pi^{(t+1)} = G^T \pi^{(t)}\)</p> <p>The value \(\pi_i\) represents the importance score of page \(i\).</p> <h3 id="markov-chains-and-steady-states">Markov Chains and Steady States</h3> <p>For a Markov chain with \(n\) states, we define a transition matrix \(P\) where \(P_{ij}\) is the probability of transitioning from state \(i\) to state \(j\):</p> \[P_{ij} = P(X_{t+1} = j | X_t = i)\] <p>Where \(\sum_{j=1}^{n} P_{ij} = 1\) for all \(i\).</p> <p>The distribution after \(t\) steps, given an initial distribution \(\mu^{(0)}\), is: \(\mu^{(t)} = \mu^{(0)} P^t\)</p> <p>For an irreducible and aperiodic Markov chain, there exists a unique stationary distribution \(\pi\) such that: \(\pi P = \pi\)</p> <p>This means \(\pi\) is the left eigenvector of \(P\) with eigenvalue 1.</p> <p>The rate of convergence to this stationary distribution is governed by the second-largest eigenvalue \(\lambda_2\) of \(P\). The smaller \(\mid\lambda_2\mid\) is compared to 1, the faster the convergence:</p> \[\mid\mu^{(t)} - \pi\mid_{TV} \leq C \cdot \mid\lambda_2\mid^t\] <p>where \(\mid\cdot\mid_{TV}\) is the total variation distance and \(C\) is a constant.</p> <p>Applications include modeling customer behavior (transitioning between brands), economic systems, genetic evolution, and even text prediction algorithms.</p> <h3 id="vibration-analysis-in-engineering">Vibration Analysis in Engineering</h3> <p>For a structure with \(n\) degrees of freedom, the equation of motion is:</p> \[M\ddot{x} + C\dot{x} + Kx = F(t)\] <p>where:</p> <ul> <li>\(M\) is the mass matrix</li> <li>\(C\) is the damping matrix</li> <li>\(K\) is the stiffness matrix</li> <li>\(x\) is the displacement vector</li> <li>\(F(t)\) is the external force vector</li> </ul> <p>For free vibration without damping (\(C = 0, F(t) = 0\)), the equation becomes: \(M\ddot{x} + Kx = 0\)</p> <p>Assuming harmonic motion \(x(t) = \phi e^{i\omega t}\), we get: \((-\omega^2 M + K)\phi = 0\)</p> <p>This is a generalized eigenvalue problem. The eigenvalues \(\lambda_i = \omega_i^2\) give the natural frequencies \(\omega_i\) of the system, and the eigenvectors \(\phi_i\) represent the mode shapes.</p> <p>The generalized eigenvalue problem can be rewritten as: \(K\phi_i = \lambda_i M\phi_i\)</p> <p>For mass-normalized eigenvectors (\(\phi_i^T M \phi_i = 1\)), the modal matrix \(\Phi = [\phi_1, \phi_2, ..., \phi_n]\) satisfies: \(\Phi^T M \Phi = I\) \(\Phi^T K \Phi = \Lambda = \text{diag}(\lambda_1, \lambda_2, ..., \lambda_n)\)</p> <p>This diagonalization allows engineers to analyze complex structures as decoupled single-degree-of-freedom systems.</p> <p>From the Tacoma Narrows Bridge collapse to the design of earthquake-resistant buildings, understanding these natural vibration modes through eigenvector analysis is crucial for safe engineering design.</p> <h3 id="quantum-mechanics">Quantum Mechanics</h3> <p>In quantum mechanics, the state of a system is described by a wave function \(\psi\), and physical observables are represented by Hermitian operators.</p> <p>For an observable \(A\) with corresponding operator \(\hat{A}\), the eigenvalue equation is: \(\hat{A}\psi_n = a_n\psi_n\)</p> <p>where \(a_n\) are the eigenvalues (possible measurement outcomes) and \(\psi_n\) are the eigenvectors (eigenstates).</p> <p>For example, the time-independent Schrödinger equation is an eigenvalue problem: \(\hat{H}\psi = E\psi\)</p> <p>where \(\hat{H}\) is the Hamiltonian operator and \(E\) represents energy levels.</p> <p>When we measure an observable \(A\), the probability of obtaining the value \(a_n\) is: \(P(a_n) = |\langle \psi_n | \psi \rangle|^2\)</p> <table> <tbody> <tr> <td>where \(\psi\) is the state before measurement and $$\langle \psi_n</td> <td>\psi \rangle$$ is the inner product.</td> </tr> </tbody> </table> <p>After the measurement, the system collapses to the eigenstate \(\psi_n\) corresponding to the measured eigenvalue \(a_n\).</p> <p>For the position operator \(\hat{x}\), the eigenvalue equation is: \(\hat{x}\psi_x = x\psi_x\)</p> <p>with eigenfunction \(\psi_x(x') = \delta(x'-x)\) (the Dirac delta function).</p> <p>For the momentum operator \(\hat{p} = -i\hbar\frac{d}{dx}\), the eigenvalue equation is: \(\hat{p}\psi_p = p\psi_p\)</p> <p>with eigenfunction \(\psi_p(x) = \frac{1}{\sqrt{2\pi\hbar}}e^{ipx/\hbar}\).</p> <p>These examples demonstrate how deeply embedded eigenvectors are in our fundamental understanding of reality itself!</p> <p>These applications show why eigenvectors and eigenvalues are not just abstract mathematical concepts but powerful tools with far-reaching practical significance across countless fields. The mathematical formulations provided here give insight into how these concepts are applied in real-world scenarios.</p> <h2 id="footnotes">Footnotes</h2> <ol> <li> <p><a href="https://www.youtube.com/watch?v=PFDu9oVAE-g" rel="external nofollow noopener" target="_blank">3Blue 1Brown’s video on Eigenvectors &amp; Eigenvalues</a> is a really nice video! The animations were really helpful for me while understanding these concepts.</p> </li> <li> <p><a href="https://setosa.io/ev/eigenvectors-and-eigenvalues/" rel="external nofollow noopener" target="_blank">Setosa.io’s blog on Eigenvectors &amp; Eigenvalues</a> are also nice tool to visualize the same.</p> </li> <li> <p><a href="https://www.youtube.com/watch?v=DzqE7tj7eIM" rel="external nofollow noopener" target="_blank">Gilbert Strang’s lecture on Eigenvectors &amp; Eigenvalues</a> give a very theoretical insight into Eigenvectors.</p> </li> </ol> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Piyush Tiwary. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-DP8LD8Z4LH"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-DP8LD8Z4LH");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>